<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous">
  <link href="/assets/css/style.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css">
  <link rel="apple-touch-icon" href="icon.png">
  <meta name="theme-color" content="#fafafa">
  <link href="https://fonts.googleapis.com/css?family=Asap" rel="stylesheet">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>ActionView::Helpers::CacheHelper | RailsDoc(β)</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="ActionView::Helpers::CacheHelper" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Ruby on Rails API Documentation." />
<meta property="og:description" content="Ruby on Rails API Documentation." />
<link rel="canonical" href="https://railsdoc.github.io/7.0/classes/ActionView/Helpers/CacheHelper.html" />
<meta property="og:url" content="https://railsdoc.github.io/7.0/classes/ActionView/Helpers/CacheHelper.html" />
<meta property="og:site_name" content="RailsDoc(β)" />
<meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="https://avatars.githubusercontent.com/u/4223" />
<meta property="twitter:title" content="ActionView::Helpers::CacheHelper" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Ruby on Rails API Documentation.","headline":"ActionView::Helpers::CacheHelper","image":"https://avatars.githubusercontent.com/u/4223","url":"https://railsdoc.github.io/7.0/classes/ActionView/Helpers/CacheHelper.html"}</script>
<!-- End Jekyll SEO tag -->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134470810-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-134470810-1');

    window.config = {
      rootPath: "/7.0/"
    }
  </script>
</head>
<body>
  <header class="navbar navbar-dark navbar-expand bg-dark flex-md-nowrap p-0 shadow sticky-header">
    <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="/">RailsDoc(β)</a>
    <form class="w-100 d-none d-md-flex" action="/search" method="get">
      <input id="search-form" class="form-control form-control-dark" type="text" placeholder="Search" aria-label="Search" name="q">
    </form>

    <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex px-1">
      <li class="nav-item text-nowrap p-1">
        <div class="dropdown">
          <a class="dropdown-toggle nav-link" href="#" role="button" id="dropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            v7.0
          </a>
          <div class="dropdown-menu dropdown-menu-md-right" aria-labelledby="dropdownMenuLink">
            
    
    
    
        <a class="dropdown-item" href="/">v7.1</a>
    

    
    
    
        <a class="dropdown-item" href="/7.0/">v7.0</a>
    

    
    
    
        <a class="dropdown-item" href="/6.1/">v6.1</a>
    

    
    
    
        <a class="dropdown-item" href="/6.0/">v6.0</a>
    

    
    
    
        <a class="dropdown-item" href="/5.2/">v5.2</a>
    


          </div>
        </div>
      </li>
      <li class="nav-item text-nowrap p-1">
        <a class="nav-link p-2" href="https://github.com/railsdoc/railsdoc.github.io">GitHub</a>
      </li>
    </ul>
  </header>

  <div class="container-fluid">
    <div class="row">
      <nav class="col-12 col-md-3 col-xl-2 d-none d-md-block bg-light sidebar-sticky">
        <div id="navigation" class="sidebar-content">
        </div>
      </nav>

      <div class="col-12 col-md-3 col-xl-2 toc-content-sticky">
        <div class="toc-content"><ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#namespace">Namespace</a>
<ul>
<li class="toc-entry toc-h3"><a href="#class">Class</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#methods">Methods</a></li>
<li class="toc-entry toc-h2"><a href="#instance-public-methods">Instance Public methods</a>
<ul>
<li class="toc-entry toc-h3"><a href="#method-i-cache">
            
              cache(name = {}, options = {}, &amp;block)
            
          </a></li>
<li class="toc-entry toc-h3"><a href="#method-i-cache-label-Explicit+dependencies">Explicit dependencies</a></li>
<li class="toc-entry toc-h3"><a href="#method-i-cache-label-External+dependencies">External dependencies</a></li>
<li class="toc-entry toc-h3"><a href="#method-i-cache-label-Collection+Caching">Collection Caching</a></li>
<li class="toc-entry toc-h3"><a href="#method-i-cache_fragment_name">
            
              cache_fragment_name(name = {}, skip_digest: nil, digest_path: nil)
            
          </a></li>
<li class="toc-entry toc-h3"><a href="#method-i-cache_if">
            
              cache_if(condition, name = {}, options = {}, &amp;block)
            
          </a></li>
<li class="toc-entry toc-h3"><a href="#method-i-cache_unless">
            
              cache_unless(condition, name = {}, options = {}, &amp;block)
            
          </a></li>
<li class="toc-entry toc-h3"><a href="#method-i-caching-3F">
            
              caching?()
            
          </a></li>
<li class="toc-entry toc-h3"><a href="#method-i-uncacheable-21">
            
              uncacheable!()
            
          </a></li>
</ul>
</li>
</ul></div>
      </div>

      <main role="main" class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-4">
        <div class="main">
    <div class="banner">
        
            <span>Ruby on Rails 7.0.8</span><br />
        
        <div class="type">Module</div>
        <h1>
            ActionView::Helpers::CacheHelper
            
        </h1>
        <ul class="files">
            
            <li><a href="../../../files/actionview/lib/action_view/helpers/cache_helper_rb.html">actionview/lib/action_view/helpers/cache_helper.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  

  

  
  


  
    <h2 id="namespace">Namespace</h2>

    

    
      <h3 id="class">Class</h3>
      <ul>
      
        <li><a href="CacheHelper/UncacheableFragmentError.html">ActionView::Helpers::CacheHelper::UncacheableFragmentError</a></li>
      
      </ul>
    
  

  
    <h2 id="methods">Methods</h2>
    <ul>
      
        <li>
          <a href="#method-i-cache">cache</a>
        </li>
      
        <li>
          <a href="#method-i-cache_fragment_name">cache_fragment_name</a>
        </li>
      
        <li>
          <a href="#method-i-cache_if">cache_if</a>
        </li>
      
        <li>
          <a href="#method-i-cache_unless">cache_unless</a>
        </li>
      
        <li>
          <a href="#method-i-caching-3F">caching?</a>
        </li>
      
        <li>
          <a href="#method-i-uncacheable-21">uncacheable!</a>
        </li>
      
    </ul>
  

  

  
    

    

    

    

    <!-- Methods -->
    
    
      <h2 id="instance-public-methods">Instance Public methods</h2>
      
        <div class="method">
          <h3 id="method-i-cache">
            
              cache(name = {}, options = {}, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>This helper exposes a method for caching fragments of a view rather than an entire action or page. This technique is useful caching pieces like menus, lists of new topics, static HTML fragments, and so on. This method takes a block that contains the content you wish to cache.</p>

<p>The best way to use this is by doing recyclable key-based cache expiration on top of a cache store like Memcached or Redis that’ll automatically kick out old entries.</p>

<p>When using this method, you list the cache dependency as the name of the cache, like so:</p>

<pre><code>&lt;% cache project do %&gt;
  &lt;b&gt;All the topics on this project&lt;/b&gt;
  &lt;%= render project.topics %&gt;
&lt;% end %&gt;
</code></pre>

<p>This approach will assume that when a new topic is added, you’ll touch the project. The cache key generated from this call will be something like:</p>

<pre><code>views/template/action:7a1156131a6928cb0026877f8b749ac9/projects/123
      ^template path  ^template tree digest            ^class   ^id
</code></pre>

<p>This cache key is stable, but it’s combined with a cache version derived from the project record. When the project updated_at is touched, the cache_version changes, even if the key stays stable. This means that unlike a traditional key-based cache expiration approach, you won’t be generating cache trash, unused keys, simply because the dependent record is updated.</p>

<p>If your template cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of an array:</p>

<pre><code>&lt;% cache [ project, current_user ] do %&gt;
  &lt;b&gt;All the topics on this project&lt;/b&gt;
  &lt;%= render project.topics %&gt;
&lt;% end %&gt;
</code></pre>

<p>This will include both records as part of the cache key and updating either of them will expire the cache.</p>

<h4 id="method-i-cache-label-Template+digest">Template digest</h4>

<p>The template digest that’s added to the cache key is computed by taking an MD5 of the contents of the entire template file. This ensures that your caches will automatically expire when you change the template file.</p>

<p>Note that the MD5 is taken of the entire template file, not just what’s within the cache do/end call. So it’s possible that changing something outside of that call will still expire the cache.</p>

<p>Additionally, the digestor will automatically look through your template file for explicit and implicit dependencies, and include those as part of the digest.</p>

<p>The digestor can be bypassed by passing skip_digest: true as an option to the cache call:</p>

<pre><code>&lt;% cache project, skip_digest: true do %&gt;
  &lt;b&gt;All the topics on this project&lt;/b&gt;
  &lt;%= render project.topics %&gt;
&lt;% end %&gt;
</code></pre>

<h4 id="method-i-cache-label-Implicit+dependencies">Implicit dependencies</h4>

<p>Most template dependencies can be derived from calls to render in the template itself. Here are some examples of render calls that Cache Digests knows how to decode:</p>

<pre><code>render partial: &quot;comments/comment&quot;, collection: commentable.comments
render &quot;comments/comments&quot;
render &#39;comments/comments&#39;
render(&#39;comments/comments&#39;)

render &quot;header&quot; translates to render(&quot;comments/header&quot;)

render(@topic)         translates to render(&quot;topics/topic&quot;)
render(topics)         translates to render(&quot;topics/topic&quot;)
render(message.topics) translates to render(&quot;topics/topic&quot;)
</code></pre>

<p>It’s not possible to derive all render calls like that, though. Here are a few examples of things that can’t be derived:</p>

<pre><code>render group_of_attachments
render @project.documents.where(published: true).order(&#39;created_at&#39;)
</code></pre>

<p>You will have to rewrite those to the explicit form:</p>

<pre><code>render partial: &#39;attachments/attachment&#39;, collection: group_of_attachments
render partial: &#39;documents/document&#39;, collection: @project.documents.where(published: true).order(&#39;created_at&#39;)
</code></pre>

<h3 id="method-i-cache-label-Explicit+dependencies">Explicit dependencies</h3>

<p>Sometimes you’ll have template dependencies that can’t be derived at all. This is typically the case when you have template rendering that happens in helpers. Here’s an example:</p>

<pre><code>&lt;%= render_sortable_todolists @project.todolists %&gt;
</code></pre>

<p>You’ll need to use a special comment format to call those out:</p>

<pre><code>&lt;%# Template Dependency: todolists/todolist %&gt;
&lt;%= render_sortable_todolists @project.todolists %&gt;
</code></pre>

<p>In some cases, like a single table inheritance setup, you might have a bunch of explicit dependencies. Instead of writing every template out, you can use a wildcard to match any template in a directory:</p>

<pre><code>&lt;%# Template Dependency: events/* %&gt;
&lt;%= render_categorizable_events @person.events %&gt;
</code></pre>

<p>This marks every template in the directory as a dependency. To find those templates, the wildcard path must be absolutely defined from <code>app/views</code> or paths otherwise added with <code>prepend_view_path</code> or <code>append_view_path</code>. This way the wildcard for <code>app/views/recordings/events</code> would be <code>recordings/events/*</code> etc.</p>

<p>The pattern used to match explicit dependencies is <code>/# Template Dependency: (\S+)/</code>, so it’s important that you type it out just so. You can only declare one template dependency per line.</p>

<h3 id="method-i-cache-label-External+dependencies">External dependencies</h3>

<p>If you use a helper method, for example, inside a cached block and you then update that helper, you’ll have to bump the cache as well. It doesn’t really matter how you do it, but the MD5 of the template file must change. One recommendation is to simply be explicit in a comment, like:</p>

<pre><code>&lt;%# Helper Dependency Updated: May 6, 2012 at 6pm %&gt;
&lt;%= some_helper_method(person) %&gt;
</code></pre>

<p>Now all you have to do is change that timestamp when the helper method changes.</p>

<h3 id="method-i-cache-label-Collection+Caching">Collection Caching</h3>

<p>When rendering a collection of objects that each use the same partial, a <code>:cached</code> option can be passed.</p>

<p>For collections rendered such:</p>

<pre><code>&lt;%= render partial: &#39;projects/project&#39;, collection: @projects, cached: true %&gt;
</code></pre>

<p>The <code>cached: true</code> will make Action View’s rendering read several templates from cache at once instead of one call per template.</p>

<p>Templates in the collection not already cached are written to cache.</p>

<p>Works great alongside individual template fragment caching. For instance if the template the collection renders is cached like:</p>

<pre><code># projects/_project.html.erb
&lt;% cache project do %&gt;
  &lt;%# ... %&gt;
&lt;% end %&gt;
</code></pre>

<p>Any collection renders will find those cached templates when attempting to read multiple templates at once.</p>

<p>If your collection cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of a block that returns an array:</p>

<pre><code>&lt;%= render partial: &#39;projects/project&#39;, collection: @projects, cached: -&gt; project { [ project, current_user ] } %&gt;
</code></pre>

<p>This will include both records as part of the cache key and updating either of them will expire the cache.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                
              </p>
              <div id="method-i-cache_source">
                <pre><code class="ruby"><span class="ruby-comment"># File actionview/lib/action_view/helpers/cache_helper.rb, line 168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache</span>(<span class="ruby-identifier">name</span> = {}, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">controller</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:perform_caching</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">controller</span>.<span class="ruby-identifier">perform_caching</span>
    <span class="ruby-constant">CachingRegistry</span>.<span class="ruby-identifier">track_caching</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">name_options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">:skip_digest</span>)
      <span class="ruby-identifier">safe_concat</span>(<span class="ruby-identifier">fragment_for</span>(<span class="ruby-identifier">cache_fragment_name</span>(<span class="ruby-identifier">name</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">name_options</span>), <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>))
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></code></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 id="method-i-cache_fragment_name">
            
              cache_fragment_name(name = {}, skip_digest: nil, digest_path: nil)
            
          </h3>

          
            <div class="description">
              <p>This helper returns the name of a cache key for a given fragment cache call. By supplying <code>skip_digest: true</code> to cache, the digestion of cache fragments can be manually bypassed. This is useful when cache fragments cannot be manually expired unless you know the exact key which is the case when using memcached.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                
              </p>
              <div id="method-i-cache_fragment_name_source">
                <pre><code class="ruby"><span class="ruby-comment"># File actionview/lib/action_view/helpers/cache_helper.rb, line 240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_fragment_name</span>(<span class="ruby-identifier">name</span> = {}, <span class="ruby-value">skip_digest:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">digest_path:</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">skip_digest</span>
    <span class="ruby-identifier">name</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">fragment_name_with_digest</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">digest_path</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></code></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 id="method-i-cache_if">
            
              cache_if(condition, name = {}, options = {}, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Cache fragments of a view if <code>condition</code> is true</p>

<pre><code>&lt;% cache_if admin?, project do %&gt;
  &lt;b&gt;All the topics on this project&lt;/b&gt;
  &lt;%= render project.topics %&gt;
&lt;% end %&gt;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                
              </p>
              <div id="method-i-cache_if_source">
                <pre><code class="ruby"><span class="ruby-comment"># File actionview/lib/action_view/helpers/cache_helper.rb, line 215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_if</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">name</span> = {}, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">condition</span>
    <span class="ruby-identifier">cache</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></code></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 id="method-i-cache_unless">
            
              cache_unless(condition, name = {}, options = {}, &amp;block)
            
          </h3>

          
            <div class="description">
              <p>Cache fragments of a view unless <code>condition</code> is true</p>

<pre><code>&lt;% cache_unless admin?, project do %&gt;
  &lt;b&gt;All the topics on this project&lt;/b&gt;
  &lt;%= render project.topics %&gt;
&lt;% end %&gt;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                
              </p>
              <div id="method-i-cache_unless_source">
                <pre><code class="ruby"><span class="ruby-comment"># File actionview/lib/action_view/helpers/cache_helper.rb, line 231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_unless</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">name</span> = {}, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">cache_if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">condition</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></code></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 id="method-i-caching-3F">
            
              caching?()
            
          </h3>

          
            <div class="description">
              <p>Returns whether the current view fragment is within a <code>cache</code> block.</p>

<p>Useful when certain fragments aren’t cacheable:</p>

<pre><code>&lt;% cache project do %&gt;
  &lt;% raise StandardError, &quot;Caching private data!&quot; if caching? %&gt;
&lt;% end %&gt;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                
              </p>
              <div id="method-i-caching-3F_source">
                <pre><code class="ruby"><span class="ruby-comment"># File actionview/lib/action_view/helpers/cache_helper.rb, line 188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">caching?</span>
  <span class="ruby-constant">CachingRegistry</span>.<span class="ruby-identifier">caching?</span>
<span class="ruby-keyword">end</span></code></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 id="method-i-uncacheable-21">
            
              uncacheable!()
            
          </h3>

          
            <div class="description">
              <p>Raises <code>UncacheableFragmentError</code> when called from within a <code>cache</code> block.</p>

<p>Useful to denote helper methods that can’t participate in fragment caching:</p>

<pre><code>def project_name_with_time(project)
  uncacheable!
  &quot;#{project.name} - #{Time.now}&quot;
end

# Which will then raise if used within a +cache+ block:
&lt;% cache project do %&gt;
  &lt;%= project_name_with_time(project) %&gt;
&lt;% end %&gt;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                
              </p>
              <div id="method-i-uncacheable-21_source">
                <pre><code class="ruby"><span class="ruby-comment"># File actionview/lib/action_view/helpers/cache_helper.rb, line 205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uncacheable!</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">UncacheableFragmentError</span>, <span class="ruby-string">&quot;can&#39;t be fragment cached&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">caching?</span>
<span class="ruby-keyword">end</span></code></pre>
              </div>
            </div>
            
          </div>
        
      
    
  
</div>

    </div>
</div>

        <footer class="site-footer">
          <!-- <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span> -->
        </footer>
      </main>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-Fy6S3B9q64WdZWQUiU+q4/2Lc9npb8tCaSX9FK7E8HnRr0Jz8D6OP9dO5Vg3Q9ct" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js" integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="/assets/js/app.js"></script>
  <script src="/assets/js/search.js"></script>
</body>
</html>
